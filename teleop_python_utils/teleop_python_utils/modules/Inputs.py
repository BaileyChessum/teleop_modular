#!/usr/bin/env python3
#
# Copyright 2025 Bailey Chessum
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Created by Bailey Chessum on 2/8/25.
#
from rclpy.node import Node
from rclpy.lifecycle import LifecycleNode
from rclpy.qos import QoSProfile
from typing import Union, Optional, List

from teleop_msgs.msg import InputNames, InputValues, InvokedEvents, CombinedInputValues
from teleop_msgs.msg import Inputs as InputsMessage

from .EventCollection import EventCollection
from .Event import Event, Callback
from .Button import Button
from .ButtonCollection import ButtonCollection
from .Axis import Axis
from .AxisCollection import AxisCollection

# We want to support both Nodes and LifecycleNodes
NodeType = Union[Node, LifecycleNode]
QoSType = Union[QoSProfile, int]


class Inputs:
    """
    Helper class for getting input values and event invocations from teleop_modular.
    """
    DEFAULT_NAMES_QOS = 10
    DEFAULT_VALUES_QOS = 10
    DEFAULT_EVENTS_QOS = 10
    DEFAULT_SPARSE_QOS = 10

    def __init__(self, node: NodeType, auto_invoke_button_events: bool = True):
        """ Constructor for the Inputs class.

        You should call other fluent constructors after this! (e.g: .with_topics("name_topic", "name_topic/values"))

        :param node: The Node or LifecycleNode to add input subscriptions to.
        :param auto_invoke_button_events: Whether button "/down" and "/up" should be automatically generated by received
        button values, removing the need to publish those events from a teleop_node.
        """
        self.node: NodeType = node
        self.__auto_invoke_button_events: bool = auto_invoke_button_events

        # Stores input and event values
        self.events: EventCollection = EventCollection()

        self.axes: AxisCollection = AxisCollection()
        self.buttons: ButtonCollection = ButtonCollection(self.events)

        # Invoked whenever a message is received
        self.on_update: Event = self.events["update"]

        # Just holds references to any subscription that get made, to keep them alive
        self.__subscriptions = []

        self.__event_invocation_queue: List[Event] = []

        # For the split InputNames / InputValues configuration
        self.__names_subscription_created = False
        self.__names_initialized = False
        self.__axis_names: List[str] = []
        self.__button_names: List[str] = []

    # Infrequent constructor

    def with_topics(self,
                    name_topic: str,
                    combined_values_topic: Optional[str] = None,
                    values_qos: QoSType = DEFAULT_VALUES_QOS,
                    names_qos: QoSType = DEFAULT_NAMES_QOS
                    ) -> "Inputs":
        """ Alias for with_combined_topics, to help suggest this as the default fluent constructor to use.
        :return: The current object, so you can continue to chain calls to fluent constructor methods
        """
        self.with_combined_topics(name_topic, combined_values_topic, values_qos, names_qos)
        return self

    # Fluent Constructors
    def with_combined_topics(self,
                             name_topic: str,
                             combined_values_topic: Optional[str] = None,
                             values_qos: QoSType = DEFAULT_VALUES_QOS,
                             names_qos: QoSType = DEFAULT_NAMES_QOS,
                             ) -> "Inputs":
        """ Fluent constructor method to accept an InputNames topic and a CombinedInputValues topic to receive values
        and events from.
        :return: The current object, so you can continue to chain calls to fluent constructor methods
        """
        if self.__assert_names_subscription_being_created_for_first_time():
            return self
        if combined_values_topic is None:
            combined_values_topic = name_topic + "/values"
        self.__subscriptions += [
            self.node.create_subscription(InputNames, name_topic, self.__input_names_callback, names_qos),
            self.node.create_subscription(CombinedInputValues, combined_values_topic, self.__combined_values_callback, values_qos)
        ]
        return self

    def with_frequent_topics(self,
                             name_topic: str,
                             values_topic: Optional[str] = None,
                             values_qos: QoSType = DEFAULT_VALUES_QOS,
                             names_qos: QoSType = DEFAULT_NAMES_QOS
                             ) -> "Inputs":
        """ Fluent constructor method to accept an InputNames topic and an InputValues topic to receive values from.
        This message type doesn't include event invocations.
        :return: The current object, so you can continue to chain calls to fluent constructor methods
        """
        if self.__assert_names_subscription_being_created_for_first_time():
            return self
        if values_topic is None:
            values_topic = name_topic + "/values"
        self.__subscriptions += [
            self.node.create_subscription(InputNames, name_topic, self.__input_names_callback, names_qos),
            self.node.create_subscription(InputValues, values_topic, self.__input_values_callback, values_qos)
        ]
        return self

    def with_events_topic(self,
                          topic: str,
                          qos: QoSType = DEFAULT_EVENTS_QOS
                          ) -> "Inputs":
        """ Fluent constructor method to accept an InvokedEvents topic, to invoke events in self.events
        :return: The current object, so you can continue to chain calls to fluent constructor methods
        """
        self.__subscriptions += [
            self.node.create_subscription(InvokedEvents, topic, self.__invoked_events_callback, qos),
        ]
        return self

    def with_sparse_topic(self,
                          topic: str,
                          qos: QoSType = DEFAULT_SPARSE_QOS
                          ) -> "Inputs":
        """ Fluent constructor method to accept an Inputs topic, which defined the names of every input, along with
        input values. This allows inputs to be provided sparsely.
        :return: The current object, so you can continue to chain calls to fluent constructor methods
        """
        self.__subscriptions += [
            self.node.create_subscription(InputsMessage, topic, self.__sparse_inputs_callback, qos)
        ]
        return self


    def __assert_names_subscription_being_created_for_first_time(self) -> bool:
        """ Tries setting self.__names_subscription_create to True, but if it has already been set, logs a cranky
        message and returns True
        :return: True if the subscription has already been created. False if everything is fine.
        """
        if self.__names_subscription_created:
            self.node.get_logger().error("Two fluent constructors for a teleop_modular Input that both set the received"
                                         " input names were called! Please only use one source of input names.")
            return True

        self.__names_subscription_created = True
        return False

    # Update management

    def add_callback(self, callback: Callback[[]]) -> "Inputs":
        """ Adds a callback method to be called whenever an input is received. Same as .on_update.add_callback().
        :return: The current object, so you can continue to chain calls to fluent constructor methods
        """
        self.on_update.add_callback(callback)
        return self

    def get_button(self, name: str) -> Button:
        """ Gets an object that stores the value for the button with the given name. """
        return self.buttons.get(name)

    def get_axis(self, name: str) -> Axis:
        """ Gets an object that stores the value for the axis with the given name. """
        return self.axes.get(name)

    def get_event(self, name: str) -> Event:
        """ Gets an Event object for the teleop_modular event with the given name. """
        return self.events[name]

    @property
    def is_locked(self) -> bool:
        """ Shorthand for the button named "locked" -- self.buttons["locked"].value """
        return bool(self.buttons["locked"])

    def __update(self) -> None:
        """ Called whenever an input is received. """
        self.__invoke_pending_events()
        self.on_update.invoke()
        self.__clear_pending_events()

    def __invoke_pending_events(self) -> None:
        """ Invokes all pending events, but doesnt clear them from the __event_invocation_queue. """
        for event in self.__event_invocation_queue:
            event.invoke()

    def __clear_pending_events(self) -> None:
        """ Clears all pending events from the __event_invocation_queue, and resets all is_invoked flags to False. """
        for event in self.__event_invocation_queue:
            event.reset_invocation()
        self.__event_invocation_queue.clear()

    # Subscription Callbacks

    def __process_inputs(self, buttons: List[int], button_names: List[str], axes: List[float], axis_names: List[str]):
        for i in range(min(len(axis_names), len(axes))):
            name = axis_names[i]
            self.axes.get(name).value = axes[i]

        for i in range(min(len(button_names), len(buttons))):
            name = self.__button_names[i]
            button = self.buttons.get(name)

            if self.__auto_invoke_button_events:
                # Automatically generates events for buttons
                if buttons[i] != 0 and button.value == 0:
                    button.on_down.invoke_silently()
                    if button.on_down not in self.__event_invocation_queue:
                        self.__event_invocation_queue.append(button.on_down)
                elif buttons[i] == 0 and button.value != 0:
                    button.on_up.invoke_silently()
                    if button.on_up not in self.__event_invocation_queue:
                        self.__event_invocation_queue.append(button.on_up)

            button.value = buttons[i]

    def __process_input_values(self, values: InputValues):
        if not self.__names_initialized:
            self.node.get_logger().debug("Didn't set input values because the name topic hasn't sent a message yet.")
            return
        self.__process_inputs(values.buttons, self.__button_names, values.axes, self.__axis_names)

    def __process_invoked_events(self, events: InvokedEvents):
        for event_name in events.names:
            event = self.events[event_name]
            event.invoke_silently()
            self.__event_invocation_queue.append(event)

    def __input_names_callback(self, msg: InputNames):
        self.__axis_names = msg.axis_names
        self.__button_names = msg.button_names

        self.__names_initialized = True

    def __input_values_callback(self, msg: InputValues):
        self.__process_input_values(msg)
        self.__update()

    def __invoked_events_callback(self, msg: InvokedEvents):
        self.__process_invoked_events(msg)
        self.__update()

    def __combined_values_callback(self, msg: CombinedInputValues):
        self.__process_input_values(msg.values)
        self.__process_invoked_events(msg.events)
        self.__update()

    def __sparse_inputs_callback(self, msg: InputsMessage):
        self.__process_inputs(msg.buttons, msg.button_names, msg.axes, msg.axis_names)
        self.__update()
